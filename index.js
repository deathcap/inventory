// Generated by CoffeeScript 1.6.3
(function() {
  var Inventory, ItemPile, deepEqual;

  deepEqual = require('deep-equal');

  Inventory = (function() {
    function Inventory(size, opts) {
      size = size != null ? size : 10;
      this.array = new Array(size);
    }

    Inventory.prototype.give = function(itemPile) {
      var excess, i, _i, _j, _ref, _ref1;
      for (i = _i = 0, _ref = this.array.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if ((this.array[i] != null) && this.array[i].canPileWith(itemPile)) {
          excess = this.array[i].mergePile(itemPile);
        }
        if (itemPile.count === 0) {
          break;
        }
      }
      for (i = _j = 0, _ref1 = this.array.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        if (this.array[i] == null) {
          this.array[i] = new ItemPile(itemPile.item, 0);
          excess = this.array[i].mergePile(itemPile);
        }
        if (itemPile.count === 0) {
          break;
        }
      }
      return excess;
    };

    Inventory.prototype.take = function(itemPile) {
      var given, i, n, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.array.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if ((this.array[i] != null) && this.array[i].matchesTypeAndTags(itemPile)) {
          n = Math.min(itemPile.count, this.array[i].count);
          itemPile.count -= n;
          given = this.array[i].splitPile(n);
          if (this.array[i].count === 0) {
            _results.push(this.array[i] = void 0);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Inventory.prototype.toString = function() {
      var a, i, itemPile, _i, _len, _ref;
      a = [];
      _ref = this.array;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        itemPile = _ref[i];
        if (itemPile == null) {
          a.push('');
        } else {
          a.push("" + itemPile);
        }
      }
      return a.join('\t');
    };

    Inventory.fromString = function(s) {
      var items, ret, strings;
      strings = s.split('\t');
      items = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = strings.length; _i < _len; _i++) {
          s = strings[_i];
          _results.push(ItemPile.fromString(s));
        }
        return _results;
      })();
      ret = new Inventory(items.length);
      ret.array = items;
      return ret;
    };

    Inventory.prototype.size = function() {
      return this.array.length;
    };

    Inventory.prototype.slot = function(i) {
      return this.array[i];
    };

    return Inventory;

  })();

  ItemPile = (function() {
    function ItemPile(item, count, tags) {
      this.item = typeof item === 'string' ? ItemPile.itemFromString(item) : item;
      this.count = count != null ? count : 1;
      this.tags = tags != null ? tags : {};
    }

    ItemPile.maxPileSize = 64;

    ItemPile.itemFromString = function(s) {
      if (s instanceof ItemPile) {
        return s;
      }
      if (!s) {
        return '';
      } else {
        return s;
      }
    };

    ItemPile.itemToString = function(item) {
      return '' + item;
    };

    ItemPile.prototype.hasTags = function() {
      return Object.keys(this.tags).length !== 0;
    };

    ItemPile.prototype.matchesType = function(itemPile) {
      return this.item === itemPile.item;
    };

    ItemPile.prototype.matchesTypeAndCount = function(itemPile) {
      return this.item === itemPile.item && this.count === itemPile.count;
    };

    ItemPile.prototype.matchesTypeAndTags = function(itemPile) {
      return this.item === itemPile.item && deepEqual(this.tags, itemPile.tags, {
        strict: true
      });
    };

    ItemPile.prototype.matchesAll = function(itemPile) {
      return this.matchesTypeAndCount(itemPile) && deepEqual(this.tags, itemPile.tags, {
        strict: true
      });
    };

    ItemPile.prototype.canPileWith = function(itemPile) {
      if (itemPile.item !== this.item) {
        return false;
      }
      if (itemPile.hasTags() || this.hasTags()) {
        return false;
      }
      return true;
    };

    ItemPile.prototype.mergePile = function(itemPile) {
      if (!this.canPileWith(itemPile)) {
        return false;
      }
      return itemPile.count = this.increase(itemPile.count);
    };

    ItemPile.prototype.increase = function(n) {
      var excessCount, newCount, _ref;
      _ref = this.tryAdding(n), newCount = _ref[0], excessCount = _ref[1];
      this.count = newCount;
      return excessCount;
    };

    ItemPile.prototype.decrease = function(n) {
      var remainingCount, removedCount, _ref;
      _ref = this.trySubtracting(n), removedCount = _ref[0], remainingCount = _ref[1];
      this.count = remainingCount;
      return removedCount;
    };

    ItemPile.prototype.tryAdding = function(n) {
      var sum;
      sum = this.count + n;
      if (sum > ItemPile.maxPileSize) {
        return [ItemPile.maxPileSize, sum - ItemPile.maxPileSize];
      } else {
        return [sum, 0];
      }
    };

    ItemPile.prototype.trySubtracting = function(n) {
      var difference;
      difference = this.count - n;
      if (difference < 0) {
        return [this.count, n - this.count];
      } else {
        return [n, this.count - n];
      }
    };

    ItemPile.prototype.splitPile = function(n) {
      if (n > this.count) {
        return false;
      }
      this.count -= n;
      return new ItemPile(this.item, n, this.tags);
    };

    ItemPile.prototype.toString = function() {
      if (this.hasTags()) {
        return "" + this.count + ":" + this.item + " " + (JSON.stringify(this.tags));
      } else {
        return "" + this.count + ":" + this.item;
      }
    };

    ItemPile.fromString = function(s) {
      var a, count, countStr, item, itemStr, tags, tagsStr, _;
      a = s.match(/^([^:]+):([^ ]+) ?(.*)/);
      if (!a) {
        return void 0;
      }
      _ = a[0], countStr = a[1], itemStr = a[2], tagsStr = a[3];
      count = parseInt(countStr, 10);
      item = ItemPile.itemFromString(itemStr);
      if (tagsStr && tagsStr.length) {
        tags = JSON.parse(tagsStr);
      } else {
        tags = {};
      }
      return new ItemPile(item, count, tags);
    };

    return ItemPile;

  })();

  module.exports.Inventory = Inventory;

  module.exports.ItemPile = ItemPile;

}).call(this);
